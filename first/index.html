<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">   
    <link rel="shortcut icon" href="../img/favicon.ico">

    <title>Premier pas - LP Symfony3</title>

    <link href="../css/bootstrap-custom.min.css" rel="stylesheet">
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css" rel="stylesheet">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/font-hack/2.015/css/hack.min.css">
    <link href='//fonts.googleapis.com/css?family=PT+Sans:400,400italic,700,700italic&subset=latin-ext,latin' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,700italic,400,300,600,700&subset=latin-ext,latin' rel='stylesheet' type='text/css'>
    <link href="../css/base.css" rel="stylesheet">
    <link href="../css/cinder.css" rel="stylesheet">
    <link rel="stylesheet" href="../css/highlight.css">


    <link href="../css/main.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

    <script src="https://ajax.googleapis.com/ajax/libs/webfont/1.5.18/webfont.js"></script>
    <script>
    WebFont.load({
        google: {
            families: ['Open Sans', 'PT Sans']
        }
    });
    </script>

    
</head>

<body>

    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            

            <!-- Main title -->
            <a class="navbar-brand" href="..">LP Symfony3</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                
                
                    <li >
                        <a href="..">Installation</a>
                    </li>
                
                
                
                    <li class="active">
                        <a href="./">Premier pas</a>
                    </li>
                
                
                
                    <li >
                        <a href="../cms/">TP CMS</a>
                    </li>
                
                
                
                    <li >
                        <a href="../help/">Aide</a>
                    </li>
                
                
                </ul>
            

            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                        <i class="fa fa-search"></i> Search
                    </a>
                </li>
                
                    <li >
                        <a rel="next" href="..">
                            <i class="fa fa-arrow-left"></i> Previous
                        </a>
                    </li>
                    <li >
                        <a rel="prev" href="../cms/">
                            Next <i class="fa fa-arrow-right"></i>
                        </a>
                    </li>
                
                
            </ul>
        </div>
    </div>
</div>

    <div class="container">
        
        <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#introduction">Introduction</a></li>
        
    
        <li class="main "><a href="#creation-du-bundle">Création du bundle</a></li>
        
    
        <li class="main "><a href="#creation-dun-controller">Création d'un controller</a></li>
        
            <li><a href="#class-controller">Class Controller</a></li>
        
            <li><a href="#gestion-des-parametres-en-annotation">Gestion des paramètres en annotation</a></li>
        
    
        <li class="main "><a href="#gestion-du-templating">Gestion du templating</a></li>
        
            <li><a href="#localise-un-template-partial">Localisé un template partial</a></li>
        
            <li><a href="#gestion-dun-layout">Gestion d'un layout</a></li>
        
            <li><a href="#par-exemple">Par exemple</a></li>
        
            <li><a href="#creer-son-layout">Créer son layout</a></li>
        
            <li><a href="#lien">Lien</a></li>
        
            <li><a href="#web-assets">Web Assets</a></li>
        
    
        <li class="main "><a href="#tests-fonctionnels">Tests fonctionnels</a></li>
        
            <li><a href="#installation">Installation</a></li>
        
            <li><a href="#ecrire-un-test">Ecrire un test</a></li>
        
    
        <li class="main "><a href="#doctrine">Doctrine</a></li>
        
            <li><a href="#introduction_1">Introduction</a></li>
        
            <li><a href="#mise-en-place">Mise en place</a></li>
        
            <li><a href="#generer-et-mettre-a-jour-la-base-de-donnee">Générer et mettre à jour la base de donnée</a></li>
        
            <li><a href="#persister-nos-objets">Persister nos objets</a></li>
        
            <li><a href="#recuperation-des-objects">Récupération des objects</a></li>
        
            <li><a href="#mettre-a-jour-un-objet">Mettre à jour un objet</a></li>
        
            <li><a href="#recuperer-plusieurs-objets">Récupérer plusieurs objets</a></li>
        
    
        <li class="main "><a href="#gestion-des-formulaires">Gestion des Formulaires</a></li>
        
            <li><a href="#simple-form">Simple form</a></li>
        
            <li><a href="#gerer-la-soumission">Gérer la soumission</a></li>
        
            <li><a href="#formulaire-comme-un-service">Formulaire comme un service</a></li>
        
            <li><a href="#lier-a-un-formulaire-a-une-entity">Lier à un formulaire à une entity</a></li>
        
            <li><a href="#bonne-pratique">Bonne pratique</a></li>
        
            <li><a href="#rendu-templating">Rendu / templating</a></li>
        
            <li><a href="#form-theming">Form Theming</a></li>
        
    
        <li class="main "><a href="#validation-des-donnees">Validation des données</a></li>
        
            <li><a href="#par-annotation-sur-des-entites">Par annotation sur des entités</a></li>
        
    
    </ul>
</div></div>
        <div class="col-md-9" role="main">

<h1 id="introduction">Introduction</h1>
<p>Nous allons créer un premier bundle <code>TestBundle</code> afin de prendre en main le paradigme MVC dans une structure 
Symfony2.</p>
<p>Process :</p>
<ol>
<li>Création d'un bundle</li>
<li>Création d'un controller de Test</li>
<li>Création d'une action</li>
<li>Templating d'une action</li>
<li>Templating d'un layout<ol>
<li>HTML</li>
<li>CSS / Assets</li>
</ol>
</li>
<li>Tests fonctionnels</li>
<li>Doctrine / Entity</li>
<li>Formulaire</li>
</ol>
<h1 id="creation-du-bundle">Création du bundle</h1>
<p>Pour cela nous allons utliser une ligne de commande qui va nous permettre de générer un skeleton de Bundle.</p>
<p><em>Cette commande n'est à effectuer qu'en environnement de developpement</em></p>
<pre><code>$ bin/console generate:bundle
</code></pre>

<p>Un certain nombre d'informations seront nécessaires :</p>
<ol>
<li>Nom du Bundle Métier<code>TestBundle</code></li>
<li>Choisir le nom - Par convention on utilise la définition du namespace sans slash</li>
<li>Choisir la destination - <code>src/</code> car bundle application métier</li>
<li>Format de configuration - Prendre <code>annotation</code></li>
<li>Structure à générer - <code>no</code></li>
<li>Confirmation</li>
</ol>
<p><strong>Que s'est-il passé ?</strong></p>
<p>Il faut se rendre dans le répertoire <code>src/TestBundle</code> afin de voir que des fichiers ont été généré.</p>
<ol>
<li>Fichier <code>TestBundle.php</code> qui est le seul fichier obligatoire afin de charger le bundle dans le Kernel</li>
<li>Autochargement dans le <code>AppKernel</code></li>
<li>Enregistrement de la définition de nos routes dans <code>src/TestBundle/Controller/*</code> en annotation</li>
</ol>
<h1 id="creation-dun-controller">Création d'un controller</h1>
<p>Dans un controller nommé <code>DemoController</code>, il nous faut différentes actions :</p>
<ol>
<li><code>index</code> : qui permet d'afficher un texte statique</li>
<li><code>whatsMyName</code> : qui permet d'afficher une information en variable d'URL</li>
</ol>
<p>Pour chacune de ses actions créer un template propre.</p>
<h2 id="class-controller">Class Controller</h2>
<p>Une Class Controller permet de gérer différentes actions appelées par le routing.</p>
<p>Lors de la génération du skeleton de notre bundle, nous avons un répertoire <code>Controller</code>. Si nous observons 
le fichier de routing de notre application 'app/config/routing.yml', on constate que nous chargeons toutes les actions
paramétrées dans les class se trouvant dans le dossier <code>Controller</code></p>
<pre><code>lp_test:
    resource: "@TestBundle/Controller/"
    type:     annotation
    prefix:   /

app:
    resource: "@AppBundle/Controller/"
    type:     annotation
</code></pre>
<p>Donc il suffit de créer la Class ci-dessous dans un fichier nommé <code>DemoController.php</code>(nommage autoload PSR-4) :</p>
<pre><code>&lt;?php

namespace TestBundle\Controller; # déclaration du namespace

use Symfony\Bundle\FrameworkBundle\Controller\Controller; # import de la Class Controller (héritage)
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Route; # utiliser pour configuration en annotation
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Template; # utiliser pour configuration en annotation

class DemoController extends Controller
{

}
</code></pre>
<p>Et pour créer une action, il suffit d'écrire une méthode annotée dans cette classe </p>
<pre><code>/**
 * @Route("/index", name="_index") # route
 * @Template() # template partial appellé : TestBundle:Demo:index.html.twig
 */
public function indexAction()
{
    return array(   # retourne un tableau clé / valeur et les clés sont exposées dans le template
            // ...
        );    
}
</code></pre>
<p>Il existe une commande afin de générer un controller :</p>
<pre><code>$ bin/console generate:controller
</code></pre>
<h2 id="gestion-des-parametres-en-annotation">Gestion des paramètres en annotation</h2>
<pre><code> /**
  * @Route("/index/{param}") # route
  * @Template() # template partial appellé : TestBundle:Demo:index.html.twig
  */
 public function indexAction($param)
 {
     return array(   # retourne un tableau clé / valeur et les clés sont exposées dans le template
             // ...
         );    
}
</code></pre>
<p>Afin d'indiquer la récupération d'un paramètre, il faut le définir dans le route.
Il est passé en argument de la méthode.</p>
<p><strong>On peut y intégrer l'objet Request</strong></p>
<pre><code>use Symfony\Component\HttpFoundation\Request;

public function indexAction(Request $request)
{
    $page = $request-&gt;query-&gt;get('page', 1);

    // ...
}
</code></pre>
<p><a href="http://symfony.com/doc/current/book/controller.html"><span class="btn btn-info">+ informations</span></a></p>
<h1 id="gestion-du-templating">Gestion du templating</h1>
<p>Le templating dans le framework Symfony est géré par défault avec Twig. </p>
<p>Que ce soit au niveau App ou Bundle, tous les templates se localisent dans <code>Resources/views</code>.</p>
<h2 id="localise-un-template-partial">Localisé un template partial</h2>
<p>A partir d'un controller afin d'éxécuter le rendu de l'action on fait appel à un template. Il est localisé en faisant 
appel à la méthode <code>render()</code> de la class <code>Symfony\Bundle\FrameworkBundle\Controller\Controller</code> dans laquelle est 
injecté le service <code>twig</code> à qui appartient cette fonction et renvoie un object <code>Response</code>.</p>
<p><strong>En PHP</strong></p>
<pre><code>// renders app/Resources/views/hello/greetings/index.html.twig
return $this-&gt;render('hello/greetings/index.html.twig', array(
    'name' =&gt; $name
));
</code></pre>
<p><strong>En Annotation</strong></p>
<pre><code> /**
  * @Template("TestBundle:Demo:another.html.twig")
  */
</code></pre>
<h2 id="gestion-dun-layout">Gestion d'un layout</h2>
<p>Par défault, la création du projet génère un template <code>app/Ressources/views/base.html.twig</code> (block mappés) et celui-ci 
peut-être étendu grâce à la fonction twig <code>{% extends ::base.html.twig %}</code></p>
<p>On peut aussi stocké un layout dans nos Bundles. Afin de le localiser il faut utiliser le ShortName du Bundle 
<code>TestBundle:layout.html.twig</code> faisant référence au fichier se trouvant dans 
<code>src/TestBundle/Ressources/views/layout.html.twig</code> </p>
<h2 id="par-exemple">Par exemple</h2>
<p>Nous avons via la définition de notre routing attaqué le controller <code>TestBundle:DemoController:indexAction</code> qui par 
défault le rendu va être compilé dans le template <code>TestBundle:Demo:index.html.twig</code> qui est localisé dans 
<code>src/TestBundle/Resources/views/Demo/index.html.twig</code>. Dans ce template partial on fait appel à un layout que nous avons 
crééer dans notre Bundle <code>src/TestBundle/Resources/views/layout.html.twig</code>.</p>
<pre><code># src/TestBundle/Resources/views/index.html.twig
{% extends "TestBundle::layout.html.twig" %}

{% block title %}TestBundle:Demo:index{% endblock %}

{% block body %}
    &lt;h1&gt;Welcome to the Demo:index page&lt;/h1&gt;
{% endblock %}
</code></pre>
<p><a href="http://symfony.com/doc/current/book/templating.html"><span class="btn btn-info">+ informations</span></a></p>
<h2 id="creer-son-layout">Créer son layout</h2>
<p>Faire évoluer le layout en intégrant le <a href="https://getbootstrap.com/examples/starter-template/">starter template bootstrap</a> en mappant 
les zones dynamiques suivantes (block):</p>
<ul>
<li><code>{% block title %}</code> - balise title</li>
<li><code>{% block stylesheets %}</code> - import des CSS</li>
<li><code>{% block body %}</code> - corps balise body</li>
<li><code>{% block javascripts %}</code> - import des JS</li>
</ul>
<p><strong>Faire appel via un CDN, les librairies externes (CSS/JS)</strong></p>
<pre><code>&lt;!-- Latest compiled and minified CSS --&gt;
&lt;link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css" integrity="sha512-dTfge/zgoMYpP7QbHy4gWMEGsbsdZeCXz7irItjcC3sPUFtf0kuFbDz/ixG7ArTxmDjLXDmezHubeNikyKGVyQ==" crossorigin="anonymous"&gt;

&lt;!-- Optional theme --&gt;
&lt;link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap-theme.min.css" integrity="sha384-aUGj/X2zp5rLCbBxumKTCw2Z50WgIr1vs/PFN4praOTvYXWlVyh2UtNUU0KAUhAX" crossorigin="anonymous"&gt;

&lt;!-- Latest compiled and minified JavaScript --&gt;
&lt;script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js" integrity="sha512-K1qjQ+NcF2TYO/eI3M6v8EiNYZfA95pQumfvcVrTHtwQVDG+aHRqLi/ETn2uB+1JqwYqVG3LIvdm9lj6imS/pQ==" crossorigin="anonymous"&gt;&lt;/script&gt;
</code></pre>
<p class="text-primary">Bien-sûr une fois correctement mappé, faire appel à ce layout dans le rendu des deux actions définies</p>

<h2 id="lien">Lien</h2>
<p>Dans le layout, mettre en place un menu avec les 2 actions définies dans la class DemoController</p>
<p>Afin de récupérer l'url d'une action il suffit d'utiliser le helper twig spécialement fait pour Symfony2 <code>path()</code>, 
qui prend comme premier argument le nom de la route et en second, un tableau <code>{}</code> qui représente les paramètres. </p>
<pre><code>&lt;a href="{{ path('_index') }}"&gt;Go to index&lt;/a&gt;
</code></pre>
<p><strong>En annotation, on définit le nom d'une route comme ci-dessous</strong></p>
<pre><code>/**
 * @Route("/index", name="_index")
 * @Template()
 */
</code></pre>
<p><a href="http://symfony.com/doc/current/book/templating.html#linking-to-pages"><span class="btn btn-info">+ informations</span></a></p>
<h2 id="web-assets">Web Assets</h2>
<p>L'organisation des fichiers dans un projet symfony2 impose que seul le répertoire <code>web</code> est accessible du Web.
Nos fichiers static doivent y être donc stockés afin de les servir au client.</p>
<p>Ces assets, dépendants de nos bundles, doivent être stockés dans <code>src/TestBundle/Resources/public</code>. Afin de les 
rendre accessible, il faut les publier </p>
<pre><code>$ bin/console assets:install --symlink
</code></pre>

<p>L'option <code>-symlink</code> permet de faire un lien symbolique.</p>
<p>Passer les assets appelés dans le layout en CDN par le bundle <code>TestBundle</code> en local.</p>
<p><strong>Par exemple</strong></p>
<pre><code>&lt;link rel="stylesheet" href="{{ asset('css/main.css') }}" /&gt; # Stocké dans app/Resources/public/css/main.css
&lt;link rel="stylesheet" href="{{ asset('bundles/lptest/css/main.css') }}" /&gt; # Stocké dans src/TestBundle/Resources/Public/css/main.css
</code></pre>
<h3 id="assetic">Assetic</h3>
<p>Assetic se basant sur Asset est un Bundle Symfony Framework afin de gérer les fichiers static en les filtrants, comme :</p>
<ul>
<li>Compilé LESS / SAAS / CoffeeScript</li>
<li>Minifiier / Combiné</li>
<li>Optimisation d'images</li>
</ul>
<p><a href="http://symfony.com/doc/current/cookbook/assetic/asset_management.html"><span class="btn btn-info">+ informations</span></a></p>
<h1 id="tests-fonctionnels">Tests fonctionnels</h1>
<p>Symfony intègre un librairie de test unitaire <a href="https://phpunit.de/manual/current/en/">PHPUnit</a>.</p>
<h2 id="installation">Installation</h2>
<pre><code>$ wget https://phar.phpunit.de/phpunit.phar # version 5.0 si php &gt; 5.6 sinon phpunit-4.8.9.phar
$ chmod +x phpunit.phar
$ mv phpunit.phar ~/bin/phpunit
$ phpunit --version
</code></pre>
<p>Les Tests fonctionnels sont là afin tester les différentes couche de votre application du routing jusqu'à la vue :</p>
<ul>
<li>Faire un requête</li>
<li>Tester la réponse</li>
</ul>
<p>Pour cela, nous allons écrire des classes afin de simuler des actions / calculs et nous tracer / tester (<a href="https://phpunit.de/manual/4.8/en/appendixes.assertions.html">assertX)</a>) les 
résultats afin de faire remonter d'éventuelles erreurs.</p>
<h2 id="ecrire-un-test">Ecrire un test</h2>
<p>Lançons le test <code>DemoController</code> :</p>
<pre><code>phpunit -c app src/TestBundle/Tests/Controller/DemoControllerTest.php
</code></pre>
<p><em><code>-c app</code> est une option de configuration afin d'aller checher les class de test (fichier / dossier)</em></p>
<p>Avec la class <code>DemoControllerTest</code> :</p>
<pre><code>&lt;?php

namespace Lp\TestBundle\Tests\Controller;

use Symfony\Bundle\FrameworkBundle\Test\WebTestCase; # class étendue PHPUnit_Framework_TestCase

class DemoControllerTest extends WebTestCase
{
    public function testIndex()
    {
        $client = static::createClient();

        $crawler = $client-&gt;request('GET', '/index');
    }

    public function testWhatsmyname()
    {
        $client = static::createClient();

        $crawler = $client-&gt;request('GET', '/whats-my-name/geoffroy');

        $this-&gt;assertTrue(200 === $client-&gt;getResponse()-&gt;getStatusCode()); # second argument peut-être un message
    }

}
</code></pre>
<p><strong><em>Pour faire une démonstration, changer le routing de l'une des actions testées.</em></strong></p>
<p><a href="http://symfony.com/doc/current/book/testing.html"><span class="btn btn-info">+ informations</span></a></p>
<h1 id="doctrine">Doctrine</h1>
<h2 id="introduction_1">Introduction</h2>
<p>Cette librairie intégré dans la version full-stack de Symfony2 est ORM (Object Relationship Management). Un ORM permet 
de travailler dans le monde Object de PHP avec une Base de donnée. Concrètement, une table en base de donnée sera 
matérialisé par Doctrine par un Objet mappé que l'on appelle entité.</p>
<p>Afin d'appréhender cette notion, l'objectif est de créer un objet Page contenant les propriétés suivantes :</p>
<ul>
<li>Titre de page (pageTitle)</li>
<li>Titre de menu (pageMenu)</li>
<li>Chapeau (excerpt)</li>
<li>Contenu (content)</li>
</ul>
<p>Afin de connecter l'application via PDO à la base de donnée il faut renseigner les paramètres de connexion dans 
<code>app/config/parameters.yml</code></p>
<h2 id="mise-en-place">Mise en place</h2>
<p>Il faut créer une class Page que l'on va déclarer en tant qu'entité grâce au mapping (dans notre cas on choisi 
le type de configuration en annotation). Le mapping se fait grâce à l'objet <code>Doctrine\ORM\Mapping</code> :</p>
<pre><code>&lt;?php

namespace TestBundle\Entity;

use Doctrine\ORM\Mapping as ORM;

/**
 * Page
 *
 * @ORM\Table()
 * @ORM\Entity # annotation qui permet de déclarer cette object en tant qu'entity
 */
class Page
{}
</code></pre>
<p>A cette classe, nous allons ajouter des proprités que l'on va mapper :</p>
<pre><code>    /**
     * @var integer
     *
     * @ORM\Column(name="id", type="integer")
     * @ORM\Id
     * @ORM\GeneratedValue(strategy="AUTO")
     */
    private $id;

    /**
     * @var string
     *
     * @ORM\Column(name="page_title", type="string", length=255)
     */
    private $pageTitle;

    /**
     * @var string
     *
     * @ORM\Column(name="page_menu", type="string", length=255)
     */
    private $pageMenu;

    /**
     * @var string
     *
     * @ORM\Column(name="excerpt", type="text")
     */
    private $excerpt;

    /**
     * @var string
     *
     * @ORM\Column(name="content", type="text")
     */
    private $content;
</code></pre>
<p>Afin d'accéder à ces propriétés défniies il nous faut des setter et des getters qud l'on peut générer grâce à une ligne 
de commande :</p>
<pre><code>$ bin/console doctrine:generate:entities Lp/TestBundleEntity/Page
</code></pre>

<pre><code>    /**
     * Get id
     *
     * @return integer
     */
    public function getId()
    {
        return $this-&gt;id;
    }

    /**
     * Set pageTitle
     *
     * @param string $pageTitle
     *
     * @return Page
     */
    public function setPageTitle($pageTitle)
    {
        $this-&gt;pageTitle = $pageTitle;

        return $this;
    }

    /**
     * Get pageTitle
     *
     * @return string
     */
    public function getPageTitle()
    {
        return $this-&gt;pageTitle;
    }

    /**
     * Set pageMenu
     *
     * @param string $pageMenu
     *
     * @return Page
     */
    public function setPageMenu($pageMenu)
    {
        $this-&gt;pageMenu = $pageMenu;

        return $this;
    }

    /**
     * Get pageMenu
     *
     * @return string
     */
    public function getPageMenu()
    {
        return $this-&gt;pageMenu;
    }

    /**
     * Set excerpt
     *
     * @param string $excerpt
     *
     * @return Page
     */
    public function setExcerpt($excerpt)
    {
        $this-&gt;excerpt = $excerpt;

        return $this;
    }

    /**
     * Get excerpt
     *
     * @return string
     */
    public function getExcerpt()
    {
        return $this-&gt;excerpt;
    }

    /**
     * Set content
     *
     * @param string $content
     *
     * @return Page
     */
    public function setContent($content)
    {
        $this-&gt;content = $content;

        return $this;
    }

    /**
     * Get content
     *
     * @return string
     */
    public function getContent()
    {
        return $this-&gt;content;
    }
</code></pre>
<p>Biensûr, il existe une commande qui permet de générer cet type de class :</p>
<pre><code>$ bin/console doctrine:generate:entity
</code></pre>
<p>Afin de générer un skeleton d'entité, il est demandé de la caractériser :</p>
<ul>
<li>Dans quel Bundle (ShortcutBundle:Entity <code>TestBundle:Page</code></li>
<li>Création des propriétés (champs)</li>
</ul>
<p><a href="http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/basic-mapping.html"><span class="btn btn-info">+ informations sur le mapping</span></a></p>
<h2 id="generer-et-mettre-a-jour-la-base-de-donnee">Générer et mettre à jour la base de donnée</h2>
<p>On peut créer la base de donnée directement en ligne de commande :</p>
<pre><code>$ bin/console doctrine:database:create
</code></pre>
<p>Quans on crée une nouvelle entité ou qu'on met à jour une entité il faut synchroniser notre base de donnée. Cela s'
effectue par un simple ligne de commande :</p>
<pre><code>$ bin/console doctrine:schema:update --force|--dump-sql
</code></pre>
<h2 id="persister-nos-objets">Persister nos objets</h2>
<p>Créer une nouvelle classe controller que l'on nomme <code>PageController</code></p>
<p>Dans celle-ci nous créons une action <code>createAction</code> :</p>
<pre><code>// ...
use TestBundle\Entity\Page;
use Symfony\Component\HttpFoundation\Response;

// ...
public function createAction()
{
    $page = new Page; # Création d'un nouvel objet Page
    $page-&gt;setPageTitle('Page title #1'); # assignation du titre de page
    $page-&gt;setPageMenu('Page #1'); # assignation ...
    $page-&gt;setExcerpt('Lorem ipsum dolor sit amet, consectetur adipiscing elit[...] '); # assignation ...
    $page-&gt;setContent('Lorem ipsum dolor sit amet, consectetur adipiscing elit. Etiam vulputate magna ac mi bibendum, nec varius augue mattis. Vestibulum cursus magna vestibulum, fringilla magna in, lobortis risus. ');

    $em = $this-&gt;getDoctrine()-&gt;getManager(); # Récupération de l'Entity Manager de Doctrine qui gère tous les process de l'ORM

    $em-&gt;persist($page); # on persiste (management de l'enregistrement)
    $em-&gt;flush(); # on flush =&gt; on éxécute les requêtes persistées auparavant

    return new Response('Created page id '.$page-&gt;getId());

}
</code></pre>
<p>Créer au moins 5 pages en base de données.</p>
<h2 id="recuperation-des-objects">Récupération des objects</h2>
<p>Afin d'effectuer des requêtes simple pour gérer la récupération d'objet :</p>
<pre><code>public function showAction($id)
{
    $page = $this-&gt;getDoctrine()
        -&gt;getRepository('TestBundle:Page') # récupère l'objet qui représente la table page 
        -&gt;find($id); # méthode "trouve le record ayant l'id

    if (!$page) {
        throw $this-&gt;createNotFoundException(
            'No page found for id '.$id
        );
    }

    // on peut passer l'objet $page à notre template par exemple
    return [
        'page' =&gt; $page
     ]
}
</code></pre>
<p>Afficher les informations de la page ayant l'id <code>$id</code></p>
<h2 id="mettre-a-jour-un-objet">Mettre à jour un objet</h2>
<pre><code>public function updateAction($id)
{
    $em = $this-&gt;getDoctrine()-&gt;getManager();
    $page = $em-&gt;getRepository('TestBundle:Page')-&gt;find($id);

    if (!$page) {
        throw $this-&gt;createNotFoundException(
            'No page found for id '.$id
        );
    }

    $page-&gt;setContent('New content!'); # mise à jour de la propriété
    $em-&gt;flush();

    return $this-&gt;redirectToRoute('homepage');
}
</code></pre>
<h2 id="recuperer-plusieurs-objets">Récupérer plusieurs objets</h2>
<h3 id="grace-a-une-dql-doctrine-query-language">grâce à une DQL (Doctrine Query Language)</h3>
<pre><code>$em = $this-&gt;getDoctrine()-&gt;getManager();
$query = $em-&gt;createQuery(
    'SELECT p
    FROM TestBundle:Page p
    ORDER BY p.id DESC'
);

$pages = $query-&gt;getResult();
</code></pre>
<h3 id="grace-au-querybuilder">grâce au queryBuilder</h3>
<pre><code>$repository = $this-&gt;getDoctrine()
    -&gt;getRepository('TestBundle:Page');

// createQueryBuilder automatically selects FROM TestBundle:Page
// and aliases it to "p"
$query = $repository-&gt;createQueryBuilder('p')
    -&gt;orderBy('p.id', 'DESC')
    -&gt;getQuery();

$page = $query-&gt;getResult();
</code></pre>
<h1 id="gestion-des-formulaires">Gestion des Formulaires</h1>
<h2 id="simple-form">Simple form</h2>
<p>A partir d'un controller, on peut créer un simple formulaire basé ou non sur sur un objet.</p>
<pre><code>namespace Lp\TestBundle\Controller;

use TestBundle\Entity\Page;
use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\Form\Extension\Core\Type\TextType;
use Symfony\Component\Form\Extension\Core\Type\TextareaType;
use Symfony\Component\Form\Extension\Core\Type\SubmitType;

class PageController extends Controller
{
    public function newAction(Request $request)
    {
        // create a page and give it some dummy data for this example
        $page = new Page();
        $page-&gt;setTitle('Write a blog post');
        $page-&gt;setContent('Lorem lipsum');

        $form = $this-&gt;createFormBuilder($page) // FormBuilderInterface
            -&gt;add('title', TextType::class)
            -&gt;add('content', TextareaType::class)
            -&gt;add('save', SubmitType::class, array('label' =&gt; 'Create Page'))
            -&gt;getForm();

        return $this-&gt;render('page/new.html.twig', array(
            'form' =&gt; $form-&gt;createView(), // FormView
        ));
    }
}
</code></pre>
<p>Afin d'afficher le rendu, il existe des fonctions twig :</p>
<pre><code>{# Lp/TestBundle/Resources/views/page/new.html.twig #}

{{ form_start(form) }} # Ouverture du tag &lt;form&gt; avec les attr
{{ form_widget(form) }} # Tous les champs dispo (widget)
{{ form_end(form) }} # Fermeture du tag + les hidden + les crsf token
</code></pre>
<p>De plus, le system est suffisament intelligent afin de peupler les champs (<code>title</code> = <code>getTitle</code>)</p>
<h2 id="gerer-la-soumission">Gérer la soumission</h2>
<pre><code>namespace Lp\TestBundle\Controller;

use TestBundle\Entity\Page;
use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\Form\Extension\Core\Type\TextType;
use Symfony\Component\Form\Extension\Core\Type\TextareaType;
use Symfony\Component\Form\Extension\Core\Type\SubmitType;

class PageController extends Controller
{
    public function newAction(Request $request)
    {
        // create a page and give it some dummy data for this example
        $page = new Page();

        $form = $this-&gt;createFormBuilder($page) // FormBuilderInterface
            -&gt;add('title', TextType::class)
            -&gt;add('content', TextareaType::class)
            -&gt;add('save', SubmitType::class, array('label' =&gt; 'Create Page'))
            -&gt;getForm();

        $form-&gt;handleRequest($request);

        if ($form-&gt;isSubmitted() &amp;&amp; $form-&gt;isValid()) {
            // ... perform some action, such as saving the page to the database

            return $this-&gt;redirectToRoute('page_success');
        }

        return $this-&gt;render('page/new.html.twig', array(
            'form' =&gt; $form-&gt;createView(), // FormView
        ));
    }
}
</code></pre>
<h2 id="formulaire-comme-un-service">Formulaire comme un service</h2>
<p>Afin de réutiliser ce formulaire dans plusieurs, différentes actions, les bonnes pratiques nous conseille d'isoler 
la définition de ce formualaire :</p>
<pre><code>// src/TestBundle/Form/Type/PageType.php
namespace TestBundle\Form\Type;

use Symfony\Component\Form\AbstractType;
use Symfony\Component\Form\FormBuilderInterface;
use Symfony\Component\Form\Extension\Core\Type\TextType;
use Symfony\Component\Form\Extension\Core\Type\DateType;
use Symfony\Component\Form\Extension\Core\Type\SubmitType;

class PageType extends AbstractType
{
    public function buildForm(FormBuilderInterface $builder, array $options)
    {
        $builder
            -&gt;add('title', 'TextType::class)
            -&gt;add('content', TextareaType::class)
            -&gt;add('save', SubmitType::class, array('label' =&gt; 'Create Page'))
        ;
    }

    public function getName()
    {
        return 'app_page';
    }
}
</code></pre>
<p>Ensuite d'appeller cette classe dans nos différents controller :</p>
<pre><code>public function editAction()
{
    $form = $this-&gt;createForm(new PageType(), $page);
}
</code></pre>
<p>ou en le définissant en tant que service</p>
<pre><code># src/TestBundle/Resources/config/services.yml
services:
    app.form.type.page:
        class: TestBundle\Form\Type\PageType
        tags:
            - { name: form.type, alias: app_page }

public function editAction()
{
    $form = $this-&gt;createForm('app_page', $page);
}
</code></pre>
<h2 id="lier-a-un-formulaire-a-une-entity">Lier à un formulaire à une entity</h2>
<p>Dans le cas d'une entité lié à un formulaire, il faut le déclarer dans la configuration du formulaire. Cela se révélera 
trés pratique dans le mapping / hydratation</p>
<pre><code>use Symfony\Component\OptionsResolver\OptionsResolver;

public function configureOptions(OptionsResolver $resolver)
{
    $resolver-&gt;setDefaults(array(
        'data_class' =&gt; 'TestBundle\Entity\Page',
    ));
}
</code></pre>
<h2 id="bonne-pratique">Bonne pratique</h2>
<p>Tout comme il est préférable de créer une classe de formulaire afin de réutiliser et de le maintenir, il est conseillé d'
 isoler le process d'éxécution, que on appellera un Handler</p>
<p><a href="https://openclassrooms.com/courses/developpez-vos-applications-web-avec-symfony2/vos-premiers-pas-avec-les-formulaires#/id/r-1525418"><span class="btn btn-info">+ informations</span></a></p>
<h2 id="rendu-templating">Rendu / templating</h2>
<p>Afin d'effectuer le rendu dans un template avec le moteur twig d'un formulaire il existe un certain nombre d'helper, 
fourni par le composant Symfony/Form</p>
<pre><code>{# Lp/TestBundle/Resources/views/page/new.html.twig #}
{{ form_start(form) }}
    {{ form_errors(form) }}

    {{ form_row(form.title) }}
    {{ form_row(form.content) }}
{{ form_end(form) }}
</code></pre>
<p><a href="http://symfony.com/doc/current/reference/forms/twig_reference.html"><span class="btn btn-info">+ informations</span></a></p>
<h2 id="form-theming">Form Theming</h2>
<p>Chaque élément composant le formulaire (label, input, ligne, etc...) peut-être thématisé en incluant des blocks 
définissant ces éléments.</p>
<p>Par exemple afin de thémer un <code>form_row()</code> :</p>
<pre><code>{% block form_row %}
{% spaceless %}
    &lt;div class="form_row"&gt;
        {{ form_label(form) }}
        {{ form_errors(form) }}
        {{ form_widget(form) }}
    &lt;/div&gt;
{% endspaceless %}
{% endblock form_row %}
</code></pre>
<p>Ces blocks de défnition de thème peuvent être importé de manière suivante :</p>
<p><code>{% form_theme form 'form/fields.html.twig' %}</code></p>
<p><a href="http://symfony.com/doc/current/book/forms.html#form-theming"><span class="btn btn-info">+ informations</span></a></p>
<h1 id="validation-des-donnees">Validation des données</h1>
<p>Il est obligatoire de controller la pertinence des données soumises soit par un formulaire ou soit par une API ou autre 
canal..</p>
<p>Il existe un composant Symfony/Validator afin d'ajouter des contraintes à des entités par exemple 
et un certain nombre de class afin de gérer les processus.</p>
<h2 id="par-annotation-sur-des-entites">Par annotation sur des entités</h2>
<p>Pour l'exemple, nous allons partir de l'entité <code>Page</code> a laquelle nous allons ajouter des contraintes en annotation.
Nous allons rendre obligatoire les données sur <code>pageMenu</code> et <code>pageTitle</code> :</p>
<pre><code>use Symfony\Component\Validator\Constraints as Assert;

/**
 * @ORM\Table()
 * @ORM\Entity
 */
class Page
{

    /**
     * @var string
     *
     * @ORM\Column(name="page_title", type="string", length=255)
     * @Assert\NotBlank()
     */
    private $pageTitle;

    /**
     * @var string
     *
     * @ORM\Column(name="page_menu", type="string", length=255)
     * @Assert\NotBlank()
     */
    private $pageMenu;

}
</code></pre>
<h3 id="utiliser-le-service-de-validation-dans-une-action">Utiliser le service de validation dans une action</h3>
<pre><code>// create a page and give it some dummy data for this example
$page = new Page();
$page-&gt;setPageTitle('Lorem lipsum 'title);
$page-&gt;setPageMenu('Lorem lipsum');

$validator = $this-&gt;get('validator');
$errors = $validator-&gt;validate($page);

if (count($errors) &gt; 0) {
    /*
     * Uses a __toString method on the $errors variable which is a
     * ConstraintViolationList object. This gives us a nice string
     * for debugging.
     */
    $errorsString = (string) $errors;

    return new Response($errorsString);
}

return new Response('The page is valid! Yes!');
</code></pre>
<p>## Utiliser le service afin de valider un formulaire lié à une entité</p></div>
        
    </div>

    <footer class="col-md-12 text-center">
        <hr>
        <p>
        <small>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</p></small>
    </footer>

    <script src="../js/jquery-1.10.2.min.js"></script>
    <script src="../js/bootstrap-3.0.3.min.js"></script>
    <script src="../js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script>
    var base_url = '..';
    </script>
    <script data-main="../mkdocs/js/search.js" src="../mkdocs/js/require.js"></script>
    <script src="../js/base.js"></script>
    <script src="../js/main.js"></script>

    <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <button type="button" class="close" data-dismiss="modal">
                        <span aria-hidden="true">&times;</span>
                        <span class="sr-only">Close</span>
                    </button>
                    <h4 class="modal-title" id="exampleModalLabel">Search</h4>
                </div>
                <div class="modal-body">
                    <p>
                        From here you can search these documents. Enter your search terms below.
                    </p>
                    <form role="form">
                        <div class="form-group">
                            <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query">
                        </div>
                    </form>
                    <div id="mkdocs-search-results"></div>
                </div>
                <div class="modal-footer">
                </div>
            </div>
        </div>
    </div>

    </body>

</html>
